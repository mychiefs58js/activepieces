---
title: "Properties"
description: "Learn about different types of properties used in triggers / actions"
icon: 'input-pipe'
---

Properties are used in actions and triggers to collect information from the user. They are also displayed to the user for input. Here are some commonly used properties:

## Basic Properties

These properties collect basic information from the user.

### Short Text

This property collects a short text input from the user.

**Example:**

```typescript
Property.ShortText({
    displayName: 'Name',
    description: 'Enter your name',
    required: true,
    defaultValue: 'John Doe'
})
```

### Long Text

This property collects a long text input from the user.

**Example:**

```typescript
Property.LongText({
    displayName: 'Description',
    description: 'Enter a description',
    required: false
})
```

### Checkbox

This property presents a checkbox for the user to select or deselect.

**Example:**

```typescript
Property.Checkbox({
    displayName: 'Agree to Terms',
    description: 'Check this box to agree to the terms',
    required: true,
    defaultValue: false
})
```

### Markdown 

This property to show markdown snippet to the user, can be used to show documentation or instructions.

**Example:**

```typescript
Property.MarkDown({
    value: '## This is a markdown snippet'
}),
```
<Tip>
If you want to show a webhook url to the user, use `{{webhookUrl}}` in the markdown snippet.
</Tip>

### DateTime

This property collects a date and time from the user.

**Example:**

```typescript
Property.DateTime({
    displayName: 'Date and Time',
    description: 'Select a date and time',
    required: true,
    defaultValue: '2023-06-09T12:00:00Z'
})
```

### Number

This property collects a numeric input from the user.

**Example:**

```typescript
Property.Number({
    displayName: 'Quantity',
    description: 'Enter a number',
    required: true
})
```

### Static Dropdown

This property presents a dropdown menu with predefined options.

**Example:**

```typescript
Property.StaticDropdown({
    displayName: 'Country',
    description: 'Select your country',
    required: true,
    options: {
        options: [
            {
                label: 'Option One',


                value: '1'
            },
            {
                label: 'Option Two',
                value: '2'
            }
        ]
    }
})
```

### Static Multiple Dropdown

This property presents a dropdown menu with multiple selection options.

**Example:**

```typescript
Property.StaticMultiSelectDropdown({
    displayName: 'Colors',
    description: 'Select one or more colors',
    required: true,
    options: {
        options: [
            {
                label: 'Red',
                value: 'red'
            },
            {
                label: 'Green',
                value: 'green'
            },
            {
                label: 'Blue',
                value: 'blue'
            }
        ]
    }
})
```

### JSON

This property collects JSON data from the user.

**Example:**

```typescript
Property.Json({
    displayName: 'Data',
    description: 'Enter JSON data',
    required: true,
    defaultValue: {"key": "value"}
})
```

### Dictionary

This property collects key-value pairs from the user.

**Example:**

```typescript
Property.Object({
    displayName: 'Options',
    description: 'Enter key-value pairs',
    required: true,
    defaultValue: {
        key1: 'value1',
        key2: 'value2'
    }
})
```

### File

This property collects a file from the user, either by providing a URL or uploading a file.

**Example:**

```typescript
Property.File({
    displayName: 'File',
    description: 'Upload a file',
    required: true
})
```

### Array of Strings

This property collects an array of strings from the user.

**Example:**

```typescript
Property.Array({
    displayName: 'Tags',
    description: 'Enter tags',
    required: false,
    defaultValue: ['tag1', 'tag2']
})
```

## Dynamic Data Properties

These properties provide more advanced options for collecting user input.

### Dropdown

This property allows for dynamically loaded options based on the user's input.

**Example:**

```typescript
Property.Dropdown<string>({
    displayName: 'Options',
    description: 'Select an option',
    required: true,
    refreshers: ['auth'],
    options: async ({auth}) => {
        if (!auth) {
            return {
                disabled: true
            };
        }
        return {
            options: [
                {
                    label: 'Option One',
                    value: '1'
                },
                {
                    label: 'Option Two',
                    value: '2'
                }
            ]
        };
    }
})
```
<Tip>
When accessing the Piece auth, be sure to use exactly `auth` as it is hardcoded. However, for other properties, use their respective names.
</Tip>


### Multi-Select Dropdown

This property allows for multiple selections from dynamically loaded options.

**Example:**

```typescript
Property.MultiSelectDropdown<string>({
    displayName: 'Options',
    description: 'Select one or more options',
    required: true,
    refreshers: ['auth'],
    options: async ({auth}) => {
        if (!auth) {
            return {
                disabled: true
            };
        }
        return {
            options: [
                {
                    label: 'Option One',
                    value: '1'
                },
                {
                    label: 'Option Two',
                    value: '2'
                }
            ]
        };
    }
})
```
<Tip>
When accessing the Piece auth, be sure to use exactly `auth` as it is hardcoded. However, for other properties, use their respective names.
</Tip>

### Dynamic Properties

This property is used to construct forms dynamically based on API responses or user input.

**Example:**

```typescript
Property.DynamicProperties({
    description: 'Dynamic Form',
    displayName: 'Dynamic Form',
    required: true,
    refreshers: ['authentication'],
    props: async (propsValue) => {
        const authentication

 = propsValue['authentication'];
        const apiEndpoint = 'https://someapi.com';
        const response = await fetch(apiEndpoint);
        const data = await response.json();
        
        const properties = {
            prop1: Property.ShortText({
                displayName: 'Property 1',
                description: 'Enter property 1',
                required: true
            }),
            prop2: Property.Number({
                displayName: 'Property 2',
                description: 'Enter property 2',
                required: false
            })
        };
        
        return properties;
    }
})
```

## Validators and Processors
The Validators and Processors feature offers you the means to optimize data quality by efficiently processing user input and validating it accordingly. This section provides comprehensive guidance on how to effectively utilize these functionalities.

### PieceProperty Type Changes
The following four keys have been added to the `PieceProperty` type:

```typescript
defaultProcessors?: ProcessorFn[];
defaultValidators?: TypedValidatorFn<ValidationInputType>[];
processors?: ProcessorFn[];
validators?: TypedValidatorFn<ValidationInputType>[];
```

- `defaultProcessors`: Represents an array of processor functions that will always be applied to the property and cannot be overwritten.
- `defaultValidators`: Represents an array of validator functions that will always be applied to the property and cannot be overwritten.
- `processors`: Represents an optional array of processor functions that can be passed when defining the property.
- `validators`: Represents an optional array of validator functions that can be passed when defining the property.

### How to Use
To apply `defaultProcessors` and `defaultValidators` to a property, you can use them in the constructor as shown in the example below:

```typescript
DateTime<R extends boolean>(request: Properties<DateTimeProperty<R>>): R extends true ? DateTimeProperty<true> : DateTimeProperty<false> {
    return { 
        ...request, 
        defaultProcessors: [Processors.datetime],
        defaultValidators: [Validators.datetimeIso],
        valueSchema: undefined, 
        type: PropertyType.DATE_TIME, 
    } as unknown as R extends true ? DateTimeProperty<true> : DateTimeProperty<false>;
}
```

On the other hand, if you want to specify custom `processors` and `validators` for a property, you can pass them in the property definition, as demonstrated in the example below:

```typescript
text: Property.LongText({
    displayName: 'Text',
    required: true,
    validators: [Validators.url, Validators.oneOf(["activepieces.com", "www.activepieces.com"])],
})
```

### Processors

Processors act as data transformers, enabling you to transform or process user input before further processing. Here's an example of a processor function:

#### Predefined Processors

- `Processors.file: ProcessorFn<unknown, Promise<ApFile|null>>`
Processes the user input (url or base64) to convert it into an ApFile object.

- `Processors.datetime: ProcessorFn<number|string|undefined|null, string | undefined>`
Processes the user input to convert it into an ISOString.

- `Processors.number: ProcessorFn<string | number | undefined | null, number | null | undefined>`
Processes the user input to convert it into a number.

### Validators
Validators help ensure that user input meets certain criteria or constraints. Below are some examples of validator functions:

#### Predefined Validators

- `Validators.pattern(regex: string | RegExp): TypedValidatorFn<ValidationInputType.STRING>`
Validates whether the processed value matches the specified regular expression.

**Example:**

```typescript
Validators.pattern(/^[a-zA-Z0-9]+$/);
```

- `Validators.maxLength(max: number, includeBounds = false): TypedValidatorFn<ValidationInputType.STRING>`
Checks if the processed value's length is within the specified maximum limit.

**Example:**

```typescript
Validators.maxLength(100, includeBounds=true);
```

- `Validators.minLength(min: number, includeBounds = false): TypedValidatorFn<ValidationInputType.STRING>`
Checks if the processed value's length is within the specified minimum limit.

**Example:**

```typescript
Validators.minLength(41);
```


- `Validators.minValue(min: number, includeBounds = false): TypedValidatorFn<ValidationInputType.NUMBER>`
Ensures that the processed numeric value is greater than the specified minimum

**Example:**

```typescript
Validators.minValue(100);
```

- `Validators.maxValue(max: number, includeBounds = false): TypedValidatorFn<ValidationInputType.NUMBER>`
Ensures that the processed numeric value is less than the specified maximum

**Example:**

```typescript
Validators.maxValue(7);
```

- `Validators.inRange(min: number, max: number, includeBounds = false): TypedValidatorFn<ValidationInputType.NUMBER>`
Checks if the processed numeric value falls within the specified range.

**Example:**

```typescript
Validators.inRange(0, 100, true); // includeBounds is true, so the range is inclusive.
```

- `Validators.oneOf(values: unknown[]): TypedValidatorFn<any>`
Validates whether the processed value is one of the specified values.

**Example:**

```typescript
Validators.oneOf(["apple", "banana", "orange"]);
```

- `Validators.number: TypedValidatorFn<ValidationInputType.NUMBER>`
Validates whether the processed value is a valid number.

- `Validators.image: TypedValidatorFn<ValidationInputType.FILE>`
Verifies whether the processed value is a valid image file based on its extension.

- `Validators.file: TypedValidatorFn<ValidationInputType.FILE>`
Ensures that the processed value is a valid file.

- `Validators.email: TypedValidatorFn<ValidationInputType.STRING>`
Validates whether the processed value is a valid email address.

- `Validators.url: TypedValidatorFn<ValidationInputType.STRING>`
Ensures that the processed value is a valid URL.

- `Validators.datetimeIso: TypedValidatorFn<ValidationInputType.DATE_TIME>`
Validates whether the processed value is a valid ISO-formatted date and time.


### How to Add Custom Processors and Validators
To add a custom validator, you can define a function The function should return an error message string if the validation fails, or `null` if the validation passes. Here's an example:

To add a custom processor, you can define a function with this type `ProcessorFn` that takes two parameters: The function should return the processed value. Here's an example:

```typescript
const customValidator: TypedValidatorFn<ValidationInputType.STRING> = {
    type: ValidationInputType.STRING,
    fn: (property, processedValue, userInput) => {
        // Your custom validation logic here
        if (validationFails) {
            return "Validation Error: Your custom error message.";
        }
        return null;
    }
};

const customProcessor: ProcessorFn<any, any> = (property, value) => {
    // Your custom processing logic here
    return processedValue;
}

text: Property.LongText({
    displayName: 'Text',
    required: true,
    processors: [customProcessor],
    validators: [customValidator],
})
```
